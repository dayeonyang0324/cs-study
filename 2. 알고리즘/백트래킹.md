# 백트래킹 & DP(다이나믹 프로그래밍)

## 백트래킹

> '조합' 알고리즘 문제에서 조건이 만족할 때 가능한 모든 조합의 수를 구하는 것. 
>
> 트리를 검사하기 위해 DFS 방식을 사용하며 재귀로 구현한다. 

<br>

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Depthfirst.png/250px-Depthfirst.png)

#### N-Queen

> 백트래킹의 대표적인 문제로 N-Queen문제가 있다.

- N * N 체스판에 N개의 Queen을 올려놓는 경우의 수를 계산하는 방식
  - 한 칼럼에 Queen을 두고 다음 가능한 자리에 Queen을 두는 과정을 반복한다. N개의 Queen을 두었으면 카운트를 증가하고 성공하기 직전의 상태로 되돌린다. 만약에 없다면 N-1번째 칼럼에 있는 Queen을 다음에 가능한 칸으로 옮긴다. 이 과정을 반복한다. 
- 모든 경우의 수 = 칼럼의 수 ^ 한 칼럼에 퀸을 놓는 경우의 수 = N ^ N
- 시간복잡도 O(N^N)

<br>

**슈도코드**

![image-20210715203132720](백트래킹.assets/image-20210715203132720.png)

<br>

**[N-Queen Backtrack-DFS 로 구현하기]()**

```python
N = int(input())
# 방문 리스트를 행, 대각선, 대각선 각각 만들어줌
row, diag1, diag2 = [0] * N, [0] * (2 * N - 1), [0] * (2 * N - 1)


def backtrack(i):
    global cnt

    # 모든 탐색에 성공했다면 카운트하기
    if i == N:
        cnt += 1
        return

    for j in range(N):
        # 값 있는지 확인 하나라도 있으면 안됨
        if row[j] or diag1[i + j] or diag2[j - i]:
            continue

        row[j] = diag1[i + j] = diag2[j - i] = 1  # 방문체크
        backtrack(i + 1)  # 재귀
        row[j] = diag1[i + j] = diag2[j - i] = 0  # 방문취소

cnt = 0
backtrack(0)
print(cnt)

```

<br>
